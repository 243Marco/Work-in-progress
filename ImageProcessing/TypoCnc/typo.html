<html>
<head>
<title>Gabonator's typocarver</title>
<style>body {font-family:arial}</style>
</head>
<body>
Text to convert:
<input id="text" type="text" value="gabo!" onKeyUp="onTextChange()">
Font size [mm]:<input id="fontsize" type="text" value="50" size="4">
Tool diameter [mm]:<input id="tooldiam" type="text" value="3" size="4">
<input type="button" value="Calculate contours" onClick="onCalculate()"><br>

Safe-Z [mm]:<input id="safez" type="text" value="2" size="2">
Drill-Z [mm]:<input id="drillz" type="text" value="0" size="2">
Move-feedrate:<input id="movefeed" type="text" value="600" size="3">
Drill-feedrate:<input id="drillfeed" type="text" value="400" size="3">


<div id="svgcontainer"></div>
</body>

<script language="javascript" src="clipper.js"></script>
<script language="javascript" src="typocarver.js"></script>
<script language="javascript" src="opentype.js"></script>

<script language="javascript">

var svgImport = new SVGImport();
var svgExport = new SVGExport();
var typoCarver = new TypoCarver();
var gCode = new GCode();

var font = null;
var fontFileName = "Roboto-Black.ttf";
var renderedText = "";
var fontSize = 1.4066*100; 

opentype.load(fontFileName, function (err, font) {
    var amount, glyph, ctx, x, y, fontSize;
    if (err) {
        showErrorMessage(err.toString());
        return;
    }
    window.font = font;
    onFontLoaded(font);
});

var redrawTimer = null;
var lastText = "";

function onTextChange()
{
  if (!font)
    return;

  var newText = document.getElementById("text").value;
  if ( lastText == renderedText )
    return;

  if (redrawTimer)
    clearTimeout(redrawTimer);

  redrawTimer = setTimeout("onFontLoaded()", 500);
}

function onFontLoaded()
{
  renderedText = document.getElementById("text").value;
  var snapPath = font.getPath(renderedText, 20, fontSize, fontSize);
  var xyPaths = svgImport.toXYPaths( _convert(snapPath.commands) );
  var range = new Range(xyPaths);

  svgExport.transform.scalex = 2/1;
  svgExport.transform.scaley = 2/1;
  document.getElementById('svgcontainer').innerHTML = "";
  document.getElementById('svgcontainer').innerHTML += svgExport.pathToSvg(xyPaths);

  var usrFontSize = parseFloat(document.getElementById("fontsize").value);

  document.getElementById('svgcontainer').innerHTML += 
    "<br>Size: " + (range.getWidth() / 100 * usrFontSize).toFixed(2) +
    " x " + (range.getHeight() / 100 * usrFontSize).toFixed(2);
}

function onCalculate()
{
  var usrToolDiam = parseFloat(document.getElementById("tooldiam").value);
  var usrFontSize = parseFloat(document.getElementById("fontsize").value);
  var usrSafeZ = parseFloat(document.getElementById("safez").value);
  var usrDrillZ = parseFloat(document.getElementById("drillz").value);
  var usrMoveFeed = parseFloat(document.getElementById("movefeed").value);
  var usrDrillFeed = parseFloat(document.getElementById("drillfeed").value);

  var snapPath = font.getPath(renderedText, 20, fontSize, fontSize);
  var xyPaths = svgImport.toXYPaths( _convert(snapPath.commands) );

  // xyPath has height 100, consider target height (usrFontSize) 
  typoCarver.toolDiameter = usrToolDiam/usrFontSize*100;
  typoCarver.toolOverlap = 0;
  svgExport.transform.scalex = 2/1;
  svgExport.transform.scaley = 2/1;

  var xyContours = typoCarver.process(xyPaths);
  var range = new Range(xyContours);

  gCode.transform.translatex = -range.range.left;
  gCode.transform.translatey = -range.range.top;
  gCode.transform.scalex = usrFontSize/100;
  gCode.transform.scaley = -usrFontSize/100;
 
  gCode.cutFeedRate = usrDrillFeed;
  gCode.moveFeedRate = usrMoveFeed;
  gCode.safeZ = usrSafeZ;
  gCode.drillZ = usrDrillZ;

  var projectedDiameter = usrToolDiam/usrFontSize * 100 * svgExport.transform.scalex;

  document.getElementById('svgcontainer').innerHTML = "";
  document.getElementById('svgcontainer').innerHTML += svgExport.linesToSvg(xyPaths, xyContours, projectedDiameter);
  document.getElementById('svgcontainer').innerHTML += "<br>G Code:<br><textarea cols='40' rows='10'>"+gCode.build(xyContours)+"</textarea>";
}

function Range(paths)
{
  this.range = {};

  for (var i in paths)
  {
    var path = paths[i];
    for (var j in path)
    {
      var point = path[j];
      if ( typeof(this.range.left) == "undefined" )
      {
        this.range = {left:point.X, top:point.Y, right:point.X, bottom:point.Y};
        continue;
      }
      if (point.X > this.range.right)
        this.range.right = point.X;
      if (point.X < this.range.left)
        this.range.left = point.X;
      if (point.Y > this.range.top)
        this.range.top = point.Y;
      if (point.Y < this.range.bottom)
        this.range.bottom = point.Y;
    }
  }
}

Range.prototype.getWidth = function()
{
  return this.range.right - this.range.left;
}

Range.prototype.getHeight = function()
{
  return this.range.top - this.range.bottom;
}

Range.prototype.toString = function()
{
  if (typeof(this.range.left)=="undefined")
    return "empty";

  return ""+
    this.getWidth().toFixed(2) + " x " + this.getHeight().toFixed(2) + " (" +
    "left: " + this.range.left.toFixed(2) +
    " right:" + this.range.right.toFixed(2) + 
    " top:" + this.range.top.toFixed(2) + 
    " bottom:" + this.range.bottom.toFixed(2) + ")";
}

function _convert(cmds)
{
  var aux = [];
  for (var i in cmds)
  {
    var cmd = cmds[i];
    switch (cmd.type)
    {
      case 'M':
        if (aux.length > 0 ) 
          aux.push({type:'Z'}); 
        aux.push({type:cmd.type, attributes:[cmd.x, cmd.y]}); 
        break;
      case 'Q': // quadratic curve
        aux.push({type:cmd.type, attributes:[cmd.x1, cmd.y1, cmd.x, cmd.y]}); 
        break; 
      case 'L': 
        aux.push({type:cmd.type, attributes:[cmd.x, cmd.y]}); 
        break;
      case 'Z': 
        aux.push({type:cmd.type}); 
        break; 
      //TODO: cubic curve
      default:
        console.log("Dont know how to convert command '"+cmd.type+"'");
    }
  } 
  return aux;
}

</script>
</html>